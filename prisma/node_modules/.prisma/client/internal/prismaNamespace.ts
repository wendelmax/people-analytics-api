
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Department: 'Department',
  Position: 'Position',
  Skill: 'Skill',
  Employee: 'Employee',
  EmployeeSkill: 'EmployeeSkill',
  Project: 'Project',
  EmployeeProject: 'EmployeeProject',
  ProjectSkill: 'ProjectSkill',
  Training: 'Training',
  TrainingSkill: 'TrainingSkill',
  EmployeeTraining: 'EmployeeTraining',
  Feedback: 'Feedback',
  Recommendation: 'Recommendation',
  RecommendationSkill: 'RecommendationSkill',
  PerformanceReview: 'PerformanceReview',
  Goal: 'Goal',
  DevelopmentPlan: 'DevelopmentPlan',
  DevelopmentPlanItem: 'DevelopmentPlanItem',
  MentoringRelationship: 'MentoringRelationship',
  Notification: 'Notification',
  NotificationPreference: 'NotificationPreference',
  Onboarding: 'Onboarding',
  OnboardingTask: 'OnboardingTask',
  Offboarding: 'Offboarding',
  OffboardingTask: 'OffboardingTask',
  EmployeeJourney: 'EmployeeJourney',
  EmployeeJourneyTouchpoint: 'EmployeeJourneyTouchpoint',
  CareerPath: 'CareerPath',
  CareerPathStage: 'CareerPathStage',
  CareerPathPosition: 'CareerPathPosition',
  CareerPathSkill: 'CareerPathSkill',
  AuditLog: 'AuditLog',
  KnowledgeArticle: 'KnowledgeArticle',
  KnowledgeArticleSkill: 'KnowledgeArticleSkill',
  AssessmentPeriod: 'AssessmentPeriod',
  CompetencyAssessment: 'CompetencyAssessment',
  CompetencySkillAssessment: 'CompetencySkillAssessment',
  SkillProgressEntry: 'SkillProgressEntry',
  Admin: 'Admin',
  LeaveType: 'LeaveType',
  LeavePolicy: 'LeavePolicy',
  LeaveRequest: 'LeaveRequest',
  LeaveBalance: 'LeaveBalance',
  Attendance: 'Attendance',
  WorkSchedule: 'WorkSchedule'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "department" | "position" | "skill" | "employee" | "employeeSkill" | "project" | "employeeProject" | "projectSkill" | "training" | "trainingSkill" | "employeeTraining" | "feedback" | "recommendation" | "recommendationSkill" | "performanceReview" | "goal" | "developmentPlan" | "developmentPlanItem" | "mentoringRelationship" | "notification" | "notificationPreference" | "onboarding" | "onboardingTask" | "offboarding" | "offboardingTask" | "employeeJourney" | "employeeJourneyTouchpoint" | "careerPath" | "careerPathStage" | "careerPathPosition" | "careerPathSkill" | "auditLog" | "knowledgeArticle" | "knowledgeArticleSkill" | "assessmentPeriod" | "competencyAssessment" | "competencySkillAssessment" | "skillProgressEntry" | "admin" | "leaveType" | "leavePolicy" | "leaveRequest" | "leaveBalance" | "attendance" | "workSchedule"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Department: {
      payload: Prisma.$DepartmentPayload<ExtArgs>
      fields: Prisma.DepartmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findFirst: {
          args: Prisma.DepartmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findMany: {
          args: Prisma.DepartmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        create: {
          args: Prisma.DepartmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        createMany: {
          args: Prisma.DepartmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        delete: {
          args: Prisma.DepartmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        update: {
          args: Prisma.DepartmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        deleteMany: {
          args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        upsert: {
          args: Prisma.DepartmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        aggregate: {
          args: Prisma.DepartmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartment>
        }
        groupBy: {
          args: Prisma.DepartmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DepartmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentCountAggregateOutputType> | number
        }
      }
    }
    Position: {
      payload: Prisma.$PositionPayload<ExtArgs>
      fields: Prisma.PositionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PositionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        findFirst: {
          args: Prisma.PositionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        findMany: {
          args: Prisma.PositionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>[]
        }
        create: {
          args: Prisma.PositionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        createMany: {
          args: Prisma.PositionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>[]
        }
        delete: {
          args: Prisma.PositionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        update: {
          args: Prisma.PositionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        deleteMany: {
          args: Prisma.PositionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PositionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>[]
        }
        upsert: {
          args: Prisma.PositionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PositionPayload>
        }
        aggregate: {
          args: Prisma.PositionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePosition>
        }
        groupBy: {
          args: Prisma.PositionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PositionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PositionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PositionCountAggregateOutputType> | number
        }
      }
    }
    Skill: {
      payload: Prisma.$SkillPayload<ExtArgs>
      fields: Prisma.SkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>
        }
        findFirst: {
          args: Prisma.SkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>
        }
        findMany: {
          args: Prisma.SkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>[]
        }
        create: {
          args: Prisma.SkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>
        }
        createMany: {
          args: Prisma.SkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>[]
        }
        delete: {
          args: Prisma.SkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>
        }
        update: {
          args: Prisma.SkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>
        }
        deleteMany: {
          args: Prisma.SkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>[]
        }
        upsert: {
          args: Prisma.SkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillPayload>
        }
        aggregate: {
          args: Prisma.SkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSkill>
        }
        groupBy: {
          args: Prisma.SkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.SkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SkillCountAggregateOutputType> | number
        }
      }
    }
    Employee: {
      payload: Prisma.$EmployeePayload<ExtArgs>
      fields: Prisma.EmployeeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findFirst: {
          args: Prisma.EmployeeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findMany: {
          args: Prisma.EmployeeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        create: {
          args: Prisma.EmployeeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        createMany: {
          args: Prisma.EmployeeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        delete: {
          args: Prisma.EmployeeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        update: {
          args: Prisma.EmployeeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        deleteMany: {
          args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        upsert: {
          args: Prisma.EmployeeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        aggregate: {
          args: Prisma.EmployeeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployee>
        }
        groupBy: {
          args: Prisma.EmployeeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeCountAggregateOutputType> | number
        }
      }
    }
    EmployeeSkill: {
      payload: Prisma.$EmployeeSkillPayload<ExtArgs>
      fields: Prisma.EmployeeSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>
        }
        findFirst: {
          args: Prisma.EmployeeSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>
        }
        findMany: {
          args: Prisma.EmployeeSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>[]
        }
        create: {
          args: Prisma.EmployeeSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>
        }
        createMany: {
          args: Prisma.EmployeeSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>[]
        }
        delete: {
          args: Prisma.EmployeeSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>
        }
        update: {
          args: Prisma.EmployeeSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>
        }
        deleteMany: {
          args: Prisma.EmployeeSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>[]
        }
        upsert: {
          args: Prisma.EmployeeSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeSkillPayload>
        }
        aggregate: {
          args: Prisma.EmployeeSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployeeSkill>
        }
        groupBy: {
          args: Prisma.EmployeeSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeSkillCountAggregateOutputType> | number
        }
      }
    }
    Project: {
      payload: Prisma.$ProjectPayload<ExtArgs>
      fields: Prisma.ProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findFirst: {
          args: Prisma.ProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        findMany: {
          args: Prisma.ProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        create: {
          args: Prisma.ProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        createMany: {
          args: Prisma.ProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        delete: {
          args: Prisma.ProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        update: {
          args: Prisma.ProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>[]
        }
        upsert: {
          args: Prisma.ProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectPayload>
        }
        aggregate: {
          args: Prisma.ProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProject>
        }
        groupBy: {
          args: Prisma.ProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectCountAggregateOutputType> | number
        }
      }
    }
    EmployeeProject: {
      payload: Prisma.$EmployeeProjectPayload<ExtArgs>
      fields: Prisma.EmployeeProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>
        }
        findFirst: {
          args: Prisma.EmployeeProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>
        }
        findMany: {
          args: Prisma.EmployeeProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>[]
        }
        create: {
          args: Prisma.EmployeeProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>
        }
        createMany: {
          args: Prisma.EmployeeProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>[]
        }
        delete: {
          args: Prisma.EmployeeProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>
        }
        update: {
          args: Prisma.EmployeeProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>
        }
        deleteMany: {
          args: Prisma.EmployeeProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>[]
        }
        upsert: {
          args: Prisma.EmployeeProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeProjectPayload>
        }
        aggregate: {
          args: Prisma.EmployeeProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployeeProject>
        }
        groupBy: {
          args: Prisma.EmployeeProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeProjectCountAggregateOutputType> | number
        }
      }
    }
    ProjectSkill: {
      payload: Prisma.$ProjectSkillPayload<ExtArgs>
      fields: Prisma.ProjectSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
        }
        findFirst: {
          args: Prisma.ProjectSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
        }
        findMany: {
          args: Prisma.ProjectSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
        }
        create: {
          args: Prisma.ProjectSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
        }
        createMany: {
          args: Prisma.ProjectSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
        }
        delete: {
          args: Prisma.ProjectSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
        }
        update: {
          args: Prisma.ProjectSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
        }
        deleteMany: {
          args: Prisma.ProjectSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>[]
        }
        upsert: {
          args: Prisma.ProjectSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectSkillPayload>
        }
        aggregate: {
          args: Prisma.ProjectSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectSkill>
        }
        groupBy: {
          args: Prisma.ProjectSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectSkillCountAggregateOutputType> | number
        }
      }
    }
    Training: {
      payload: Prisma.$TrainingPayload<ExtArgs>
      fields: Prisma.TrainingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TrainingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>
        }
        findFirst: {
          args: Prisma.TrainingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>
        }
        findMany: {
          args: Prisma.TrainingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>[]
        }
        create: {
          args: Prisma.TrainingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>
        }
        createMany: {
          args: Prisma.TrainingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TrainingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>[]
        }
        delete: {
          args: Prisma.TrainingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>
        }
        update: {
          args: Prisma.TrainingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>
        }
        deleteMany: {
          args: Prisma.TrainingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TrainingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TrainingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>[]
        }
        upsert: {
          args: Prisma.TrainingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingPayload>
        }
        aggregate: {
          args: Prisma.TrainingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTraining>
        }
        groupBy: {
          args: Prisma.TrainingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrainingGroupByOutputType>[]
        }
        count: {
          args: Prisma.TrainingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrainingCountAggregateOutputType> | number
        }
      }
    }
    TrainingSkill: {
      payload: Prisma.$TrainingSkillPayload<ExtArgs>
      fields: Prisma.TrainingSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TrainingSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TrainingSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>
        }
        findFirst: {
          args: Prisma.TrainingSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TrainingSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>
        }
        findMany: {
          args: Prisma.TrainingSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>[]
        }
        create: {
          args: Prisma.TrainingSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>
        }
        createMany: {
          args: Prisma.TrainingSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TrainingSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>[]
        }
        delete: {
          args: Prisma.TrainingSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>
        }
        update: {
          args: Prisma.TrainingSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>
        }
        deleteMany: {
          args: Prisma.TrainingSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TrainingSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TrainingSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>[]
        }
        upsert: {
          args: Prisma.TrainingSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TrainingSkillPayload>
        }
        aggregate: {
          args: Prisma.TrainingSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTrainingSkill>
        }
        groupBy: {
          args: Prisma.TrainingSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrainingSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.TrainingSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TrainingSkillCountAggregateOutputType> | number
        }
      }
    }
    EmployeeTraining: {
      payload: Prisma.$EmployeeTrainingPayload<ExtArgs>
      fields: Prisma.EmployeeTrainingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeTrainingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeTrainingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>
        }
        findFirst: {
          args: Prisma.EmployeeTrainingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeTrainingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>
        }
        findMany: {
          args: Prisma.EmployeeTrainingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>[]
        }
        create: {
          args: Prisma.EmployeeTrainingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>
        }
        createMany: {
          args: Prisma.EmployeeTrainingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeTrainingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>[]
        }
        delete: {
          args: Prisma.EmployeeTrainingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>
        }
        update: {
          args: Prisma.EmployeeTrainingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>
        }
        deleteMany: {
          args: Prisma.EmployeeTrainingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeTrainingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeTrainingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>[]
        }
        upsert: {
          args: Prisma.EmployeeTrainingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeTrainingPayload>
        }
        aggregate: {
          args: Prisma.EmployeeTrainingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployeeTraining>
        }
        groupBy: {
          args: Prisma.EmployeeTrainingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeTrainingGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeTrainingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeTrainingCountAggregateOutputType> | number
        }
      }
    }
    Feedback: {
      payload: Prisma.$FeedbackPayload<ExtArgs>
      fields: Prisma.FeedbackFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        findFirst: {
          args: Prisma.FeedbackFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        findMany: {
          args: Prisma.FeedbackFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
        }
        create: {
          args: Prisma.FeedbackCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        createMany: {
          args: Prisma.FeedbackCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
        }
        delete: {
          args: Prisma.FeedbackDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        update: {
          args: Prisma.FeedbackUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        deleteMany: {
          args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
        }
        upsert: {
          args: Prisma.FeedbackUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FeedbackPayload>
        }
        aggregate: {
          args: Prisma.FeedbackAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFeedback>
        }
        groupBy: {
          args: Prisma.FeedbackGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackGroupByOutputType>[]
        }
        count: {
          args: Prisma.FeedbackCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FeedbackCountAggregateOutputType> | number
        }
      }
    }
    Recommendation: {
      payload: Prisma.$RecommendationPayload<ExtArgs>
      fields: Prisma.RecommendationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RecommendationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RecommendationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>
        }
        findFirst: {
          args: Prisma.RecommendationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RecommendationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>
        }
        findMany: {
          args: Prisma.RecommendationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
        }
        create: {
          args: Prisma.RecommendationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>
        }
        createMany: {
          args: Prisma.RecommendationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RecommendationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
        }
        delete: {
          args: Prisma.RecommendationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>
        }
        update: {
          args: Prisma.RecommendationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>
        }
        deleteMany: {
          args: Prisma.RecommendationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RecommendationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RecommendationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
        }
        upsert: {
          args: Prisma.RecommendationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationPayload>
        }
        aggregate: {
          args: Prisma.RecommendationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecommendation>
        }
        groupBy: {
          args: Prisma.RecommendationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecommendationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RecommendationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecommendationCountAggregateOutputType> | number
        }
      }
    }
    RecommendationSkill: {
      payload: Prisma.$RecommendationSkillPayload<ExtArgs>
      fields: Prisma.RecommendationSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RecommendationSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RecommendationSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>
        }
        findFirst: {
          args: Prisma.RecommendationSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RecommendationSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>
        }
        findMany: {
          args: Prisma.RecommendationSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>[]
        }
        create: {
          args: Prisma.RecommendationSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>
        }
        createMany: {
          args: Prisma.RecommendationSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RecommendationSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>[]
        }
        delete: {
          args: Prisma.RecommendationSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>
        }
        update: {
          args: Prisma.RecommendationSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>
        }
        deleteMany: {
          args: Prisma.RecommendationSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RecommendationSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RecommendationSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>[]
        }
        upsert: {
          args: Prisma.RecommendationSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecommendationSkillPayload>
        }
        aggregate: {
          args: Prisma.RecommendationSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecommendationSkill>
        }
        groupBy: {
          args: Prisma.RecommendationSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecommendationSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.RecommendationSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecommendationSkillCountAggregateOutputType> | number
        }
      }
    }
    PerformanceReview: {
      payload: Prisma.$PerformanceReviewPayload<ExtArgs>
      fields: Prisma.PerformanceReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PerformanceReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
        }
        findFirst: {
          args: Prisma.PerformanceReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PerformanceReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
        }
        findMany: {
          args: Prisma.PerformanceReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
        }
        create: {
          args: Prisma.PerformanceReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
        }
        createMany: {
          args: Prisma.PerformanceReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PerformanceReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
        }
        delete: {
          args: Prisma.PerformanceReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
        }
        update: {
          args: Prisma.PerformanceReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
        }
        deleteMany: {
          args: Prisma.PerformanceReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PerformanceReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PerformanceReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
        }
        upsert: {
          args: Prisma.PerformanceReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
        }
        aggregate: {
          args: Prisma.PerformanceReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerformanceReview>
        }
        groupBy: {
          args: Prisma.PerformanceReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerformanceReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.PerformanceReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerformanceReviewCountAggregateOutputType> | number
        }
      }
    }
    Goal: {
      payload: Prisma.$GoalPayload<ExtArgs>
      fields: Prisma.GoalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GoalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GoalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        findFirst: {
          args: Prisma.GoalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GoalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        findMany: {
          args: Prisma.GoalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>[]
        }
        create: {
          args: Prisma.GoalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        createMany: {
          args: Prisma.GoalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GoalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>[]
        }
        delete: {
          args: Prisma.GoalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        update: {
          args: Prisma.GoalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        deleteMany: {
          args: Prisma.GoalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GoalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GoalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>[]
        }
        upsert: {
          args: Prisma.GoalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoalPayload>
        }
        aggregate: {
          args: Prisma.GoalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGoal>
        }
        groupBy: {
          args: Prisma.GoalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoalGroupByOutputType>[]
        }
        count: {
          args: Prisma.GoalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoalCountAggregateOutputType> | number
        }
      }
    }
    DevelopmentPlan: {
      payload: Prisma.$DevelopmentPlanPayload<ExtArgs>
      fields: Prisma.DevelopmentPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DevelopmentPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DevelopmentPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>
        }
        findFirst: {
          args: Prisma.DevelopmentPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DevelopmentPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>
        }
        findMany: {
          args: Prisma.DevelopmentPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>[]
        }
        create: {
          args: Prisma.DevelopmentPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>
        }
        createMany: {
          args: Prisma.DevelopmentPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DevelopmentPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>[]
        }
        delete: {
          args: Prisma.DevelopmentPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>
        }
        update: {
          args: Prisma.DevelopmentPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>
        }
        deleteMany: {
          args: Prisma.DevelopmentPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DevelopmentPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DevelopmentPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>[]
        }
        upsert: {
          args: Prisma.DevelopmentPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanPayload>
        }
        aggregate: {
          args: Prisma.DevelopmentPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDevelopmentPlan>
        }
        groupBy: {
          args: Prisma.DevelopmentPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DevelopmentPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.DevelopmentPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DevelopmentPlanCountAggregateOutputType> | number
        }
      }
    }
    DevelopmentPlanItem: {
      payload: Prisma.$DevelopmentPlanItemPayload<ExtArgs>
      fields: Prisma.DevelopmentPlanItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DevelopmentPlanItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DevelopmentPlanItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>
        }
        findFirst: {
          args: Prisma.DevelopmentPlanItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DevelopmentPlanItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>
        }
        findMany: {
          args: Prisma.DevelopmentPlanItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>[]
        }
        create: {
          args: Prisma.DevelopmentPlanItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>
        }
        createMany: {
          args: Prisma.DevelopmentPlanItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DevelopmentPlanItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>[]
        }
        delete: {
          args: Prisma.DevelopmentPlanItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>
        }
        update: {
          args: Prisma.DevelopmentPlanItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>
        }
        deleteMany: {
          args: Prisma.DevelopmentPlanItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DevelopmentPlanItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DevelopmentPlanItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>[]
        }
        upsert: {
          args: Prisma.DevelopmentPlanItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DevelopmentPlanItemPayload>
        }
        aggregate: {
          args: Prisma.DevelopmentPlanItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDevelopmentPlanItem>
        }
        groupBy: {
          args: Prisma.DevelopmentPlanItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DevelopmentPlanItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.DevelopmentPlanItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DevelopmentPlanItemCountAggregateOutputType> | number
        }
      }
    }
    MentoringRelationship: {
      payload: Prisma.$MentoringRelationshipPayload<ExtArgs>
      fields: Prisma.MentoringRelationshipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MentoringRelationshipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MentoringRelationshipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>
        }
        findFirst: {
          args: Prisma.MentoringRelationshipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MentoringRelationshipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>
        }
        findMany: {
          args: Prisma.MentoringRelationshipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>[]
        }
        create: {
          args: Prisma.MentoringRelationshipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>
        }
        createMany: {
          args: Prisma.MentoringRelationshipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MentoringRelationshipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>[]
        }
        delete: {
          args: Prisma.MentoringRelationshipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>
        }
        update: {
          args: Prisma.MentoringRelationshipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>
        }
        deleteMany: {
          args: Prisma.MentoringRelationshipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MentoringRelationshipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MentoringRelationshipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>[]
        }
        upsert: {
          args: Prisma.MentoringRelationshipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentoringRelationshipPayload>
        }
        aggregate: {
          args: Prisma.MentoringRelationshipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMentoringRelationship>
        }
        groupBy: {
          args: Prisma.MentoringRelationshipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MentoringRelationshipGroupByOutputType>[]
        }
        count: {
          args: Prisma.MentoringRelationshipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MentoringRelationshipCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    NotificationPreference: {
      payload: Prisma.$NotificationPreferencePayload<ExtArgs>
      fields: Prisma.NotificationPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findFirst: {
          args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findMany: {
          args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        create: {
          args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        createMany: {
          args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        delete: {
          args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        update: {
          args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        deleteMany: {
          args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        upsert: {
          args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        aggregate: {
          args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreference>
        }
        groupBy: {
          args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceCountAggregateOutputType> | number
        }
      }
    }
    Onboarding: {
      payload: Prisma.$OnboardingPayload<ExtArgs>
      fields: Prisma.OnboardingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>
        }
        findFirst: {
          args: Prisma.OnboardingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>
        }
        findMany: {
          args: Prisma.OnboardingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>[]
        }
        create: {
          args: Prisma.OnboardingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>
        }
        createMany: {
          args: Prisma.OnboardingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OnboardingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>[]
        }
        delete: {
          args: Prisma.OnboardingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>
        }
        update: {
          args: Prisma.OnboardingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>
        }
        deleteMany: {
          args: Prisma.OnboardingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OnboardingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>[]
        }
        upsert: {
          args: Prisma.OnboardingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPayload>
        }
        aggregate: {
          args: Prisma.OnboardingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboarding>
        }
        groupBy: {
          args: Prisma.OnboardingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingCountAggregateOutputType> | number
        }
      }
    }
    OnboardingTask: {
      payload: Prisma.$OnboardingTaskPayload<ExtArgs>
      fields: Prisma.OnboardingTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>
        }
        findFirst: {
          args: Prisma.OnboardingTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>
        }
        findMany: {
          args: Prisma.OnboardingTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>[]
        }
        create: {
          args: Prisma.OnboardingTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>
        }
        createMany: {
          args: Prisma.OnboardingTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OnboardingTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>[]
        }
        delete: {
          args: Prisma.OnboardingTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>
        }
        update: {
          args: Prisma.OnboardingTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>
        }
        deleteMany: {
          args: Prisma.OnboardingTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OnboardingTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>[]
        }
        upsert: {
          args: Prisma.OnboardingTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingTaskPayload>
        }
        aggregate: {
          args: Prisma.OnboardingTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboardingTask>
        }
        groupBy: {
          args: Prisma.OnboardingTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingTaskCountAggregateOutputType> | number
        }
      }
    }
    Offboarding: {
      payload: Prisma.$OffboardingPayload<ExtArgs>
      fields: Prisma.OffboardingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OffboardingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OffboardingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>
        }
        findFirst: {
          args: Prisma.OffboardingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OffboardingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>
        }
        findMany: {
          args: Prisma.OffboardingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>[]
        }
        create: {
          args: Prisma.OffboardingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>
        }
        createMany: {
          args: Prisma.OffboardingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OffboardingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>[]
        }
        delete: {
          args: Prisma.OffboardingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>
        }
        update: {
          args: Prisma.OffboardingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>
        }
        deleteMany: {
          args: Prisma.OffboardingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OffboardingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OffboardingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>[]
        }
        upsert: {
          args: Prisma.OffboardingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingPayload>
        }
        aggregate: {
          args: Prisma.OffboardingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffboarding>
        }
        groupBy: {
          args: Prisma.OffboardingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OffboardingGroupByOutputType>[]
        }
        count: {
          args: Prisma.OffboardingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OffboardingCountAggregateOutputType> | number
        }
      }
    }
    OffboardingTask: {
      payload: Prisma.$OffboardingTaskPayload<ExtArgs>
      fields: Prisma.OffboardingTaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OffboardingTaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OffboardingTaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>
        }
        findFirst: {
          args: Prisma.OffboardingTaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OffboardingTaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>
        }
        findMany: {
          args: Prisma.OffboardingTaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>[]
        }
        create: {
          args: Prisma.OffboardingTaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>
        }
        createMany: {
          args: Prisma.OffboardingTaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OffboardingTaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>[]
        }
        delete: {
          args: Prisma.OffboardingTaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>
        }
        update: {
          args: Prisma.OffboardingTaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>
        }
        deleteMany: {
          args: Prisma.OffboardingTaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OffboardingTaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OffboardingTaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>[]
        }
        upsert: {
          args: Prisma.OffboardingTaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OffboardingTaskPayload>
        }
        aggregate: {
          args: Prisma.OffboardingTaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOffboardingTask>
        }
        groupBy: {
          args: Prisma.OffboardingTaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OffboardingTaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.OffboardingTaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OffboardingTaskCountAggregateOutputType> | number
        }
      }
    }
    EmployeeJourney: {
      payload: Prisma.$EmployeeJourneyPayload<ExtArgs>
      fields: Prisma.EmployeeJourneyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeJourneyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeJourneyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>
        }
        findFirst: {
          args: Prisma.EmployeeJourneyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeJourneyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>
        }
        findMany: {
          args: Prisma.EmployeeJourneyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>[]
        }
        create: {
          args: Prisma.EmployeeJourneyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>
        }
        createMany: {
          args: Prisma.EmployeeJourneyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeJourneyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>[]
        }
        delete: {
          args: Prisma.EmployeeJourneyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>
        }
        update: {
          args: Prisma.EmployeeJourneyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>
        }
        deleteMany: {
          args: Prisma.EmployeeJourneyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeJourneyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeJourneyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>[]
        }
        upsert: {
          args: Prisma.EmployeeJourneyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyPayload>
        }
        aggregate: {
          args: Prisma.EmployeeJourneyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployeeJourney>
        }
        groupBy: {
          args: Prisma.EmployeeJourneyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeJourneyGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeJourneyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeJourneyCountAggregateOutputType> | number
        }
      }
    }
    EmployeeJourneyTouchpoint: {
      payload: Prisma.$EmployeeJourneyTouchpointPayload<ExtArgs>
      fields: Prisma.EmployeeJourneyTouchpointFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeJourneyTouchpointFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeJourneyTouchpointFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>
        }
        findFirst: {
          args: Prisma.EmployeeJourneyTouchpointFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeJourneyTouchpointFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>
        }
        findMany: {
          args: Prisma.EmployeeJourneyTouchpointFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>[]
        }
        create: {
          args: Prisma.EmployeeJourneyTouchpointCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>
        }
        createMany: {
          args: Prisma.EmployeeJourneyTouchpointCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeJourneyTouchpointCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>[]
        }
        delete: {
          args: Prisma.EmployeeJourneyTouchpointDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>
        }
        update: {
          args: Prisma.EmployeeJourneyTouchpointUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>
        }
        deleteMany: {
          args: Prisma.EmployeeJourneyTouchpointDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeJourneyTouchpointUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeJourneyTouchpointUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>[]
        }
        upsert: {
          args: Prisma.EmployeeJourneyTouchpointUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeeJourneyTouchpointPayload>
        }
        aggregate: {
          args: Prisma.EmployeeJourneyTouchpointAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployeeJourneyTouchpoint>
        }
        groupBy: {
          args: Prisma.EmployeeJourneyTouchpointGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeJourneyTouchpointGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeJourneyTouchpointCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeJourneyTouchpointCountAggregateOutputType> | number
        }
      }
    }
    CareerPath: {
      payload: Prisma.$CareerPathPayload<ExtArgs>
      fields: Prisma.CareerPathFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareerPathFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareerPathFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>
        }
        findFirst: {
          args: Prisma.CareerPathFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareerPathFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>
        }
        findMany: {
          args: Prisma.CareerPathFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>[]
        }
        create: {
          args: Prisma.CareerPathCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>
        }
        createMany: {
          args: Prisma.CareerPathCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareerPathCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>[]
        }
        delete: {
          args: Prisma.CareerPathDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>
        }
        update: {
          args: Prisma.CareerPathUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>
        }
        deleteMany: {
          args: Prisma.CareerPathDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareerPathUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareerPathUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>[]
        }
        upsert: {
          args: Prisma.CareerPathUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPayload>
        }
        aggregate: {
          args: Prisma.CareerPathAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareerPath>
        }
        groupBy: {
          args: Prisma.CareerPathGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareerPathCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathCountAggregateOutputType> | number
        }
      }
    }
    CareerPathStage: {
      payload: Prisma.$CareerPathStagePayload<ExtArgs>
      fields: Prisma.CareerPathStageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareerPathStageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareerPathStageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>
        }
        findFirst: {
          args: Prisma.CareerPathStageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareerPathStageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>
        }
        findMany: {
          args: Prisma.CareerPathStageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>[]
        }
        create: {
          args: Prisma.CareerPathStageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>
        }
        createMany: {
          args: Prisma.CareerPathStageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareerPathStageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>[]
        }
        delete: {
          args: Prisma.CareerPathStageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>
        }
        update: {
          args: Prisma.CareerPathStageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>
        }
        deleteMany: {
          args: Prisma.CareerPathStageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareerPathStageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareerPathStageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>[]
        }
        upsert: {
          args: Prisma.CareerPathStageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathStagePayload>
        }
        aggregate: {
          args: Prisma.CareerPathStageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareerPathStage>
        }
        groupBy: {
          args: Prisma.CareerPathStageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathStageGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareerPathStageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathStageCountAggregateOutputType> | number
        }
      }
    }
    CareerPathPosition: {
      payload: Prisma.$CareerPathPositionPayload<ExtArgs>
      fields: Prisma.CareerPathPositionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareerPathPositionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareerPathPositionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>
        }
        findFirst: {
          args: Prisma.CareerPathPositionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareerPathPositionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>
        }
        findMany: {
          args: Prisma.CareerPathPositionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>[]
        }
        create: {
          args: Prisma.CareerPathPositionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>
        }
        createMany: {
          args: Prisma.CareerPathPositionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareerPathPositionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>[]
        }
        delete: {
          args: Prisma.CareerPathPositionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>
        }
        update: {
          args: Prisma.CareerPathPositionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>
        }
        deleteMany: {
          args: Prisma.CareerPathPositionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareerPathPositionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareerPathPositionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>[]
        }
        upsert: {
          args: Prisma.CareerPathPositionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathPositionPayload>
        }
        aggregate: {
          args: Prisma.CareerPathPositionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareerPathPosition>
        }
        groupBy: {
          args: Prisma.CareerPathPositionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathPositionGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareerPathPositionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathPositionCountAggregateOutputType> | number
        }
      }
    }
    CareerPathSkill: {
      payload: Prisma.$CareerPathSkillPayload<ExtArgs>
      fields: Prisma.CareerPathSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareerPathSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareerPathSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>
        }
        findFirst: {
          args: Prisma.CareerPathSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareerPathSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>
        }
        findMany: {
          args: Prisma.CareerPathSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>[]
        }
        create: {
          args: Prisma.CareerPathSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>
        }
        createMany: {
          args: Prisma.CareerPathSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareerPathSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>[]
        }
        delete: {
          args: Prisma.CareerPathSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>
        }
        update: {
          args: Prisma.CareerPathSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>
        }
        deleteMany: {
          args: Prisma.CareerPathSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareerPathSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareerPathSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>[]
        }
        upsert: {
          args: Prisma.CareerPathSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareerPathSkillPayload>
        }
        aggregate: {
          args: Prisma.CareerPathSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareerPathSkill>
        }
        groupBy: {
          args: Prisma.CareerPathSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareerPathSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareerPathSkillCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    KnowledgeArticle: {
      payload: Prisma.$KnowledgeArticlePayload<ExtArgs>
      fields: Prisma.KnowledgeArticleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KnowledgeArticleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
        }
        findFirst: {
          args: Prisma.KnowledgeArticleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
        }
        findMany: {
          args: Prisma.KnowledgeArticleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
        }
        create: {
          args: Prisma.KnowledgeArticleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
        }
        createMany: {
          args: Prisma.KnowledgeArticleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
        }
        delete: {
          args: Prisma.KnowledgeArticleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
        }
        update: {
          args: Prisma.KnowledgeArticleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
        }
        deleteMany: {
          args: Prisma.KnowledgeArticleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KnowledgeArticleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KnowledgeArticleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
        }
        upsert: {
          args: Prisma.KnowledgeArticleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
        }
        aggregate: {
          args: Prisma.KnowledgeArticleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKnowledgeArticle>
        }
        groupBy: {
          args: Prisma.KnowledgeArticleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KnowledgeArticleGroupByOutputType>[]
        }
        count: {
          args: Prisma.KnowledgeArticleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KnowledgeArticleCountAggregateOutputType> | number
        }
      }
    }
    KnowledgeArticleSkill: {
      payload: Prisma.$KnowledgeArticleSkillPayload<ExtArgs>
      fields: Prisma.KnowledgeArticleSkillFieldRefs
      operations: {
        findUnique: {
          args: Prisma.KnowledgeArticleSkillFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.KnowledgeArticleSkillFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>
        }
        findFirst: {
          args: Prisma.KnowledgeArticleSkillFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.KnowledgeArticleSkillFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>
        }
        findMany: {
          args: Prisma.KnowledgeArticleSkillFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>[]
        }
        create: {
          args: Prisma.KnowledgeArticleSkillCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>
        }
        createMany: {
          args: Prisma.KnowledgeArticleSkillCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.KnowledgeArticleSkillCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>[]
        }
        delete: {
          args: Prisma.KnowledgeArticleSkillDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>
        }
        update: {
          args: Prisma.KnowledgeArticleSkillUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>
        }
        deleteMany: {
          args: Prisma.KnowledgeArticleSkillDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.KnowledgeArticleSkillUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.KnowledgeArticleSkillUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>[]
        }
        upsert: {
          args: Prisma.KnowledgeArticleSkillUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$KnowledgeArticleSkillPayload>
        }
        aggregate: {
          args: Prisma.KnowledgeArticleSkillAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateKnowledgeArticleSkill>
        }
        groupBy: {
          args: Prisma.KnowledgeArticleSkillGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KnowledgeArticleSkillGroupByOutputType>[]
        }
        count: {
          args: Prisma.KnowledgeArticleSkillCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.KnowledgeArticleSkillCountAggregateOutputType> | number
        }
      }
    }
    AssessmentPeriod: {
      payload: Prisma.$AssessmentPeriodPayload<ExtArgs>
      fields: Prisma.AssessmentPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssessmentPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssessmentPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>
        }
        findFirst: {
          args: Prisma.AssessmentPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssessmentPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>
        }
        findMany: {
          args: Prisma.AssessmentPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>[]
        }
        create: {
          args: Prisma.AssessmentPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>
        }
        createMany: {
          args: Prisma.AssessmentPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssessmentPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>[]
        }
        delete: {
          args: Prisma.AssessmentPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>
        }
        update: {
          args: Prisma.AssessmentPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>
        }
        deleteMany: {
          args: Prisma.AssessmentPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssessmentPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssessmentPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>[]
        }
        upsert: {
          args: Prisma.AssessmentPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssessmentPeriodPayload>
        }
        aggregate: {
          args: Prisma.AssessmentPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssessmentPeriod>
        }
        groupBy: {
          args: Prisma.AssessmentPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssessmentPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssessmentPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssessmentPeriodCountAggregateOutputType> | number
        }
      }
    }
    CompetencyAssessment: {
      payload: Prisma.$CompetencyAssessmentPayload<ExtArgs>
      fields: Prisma.CompetencyAssessmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompetencyAssessmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompetencyAssessmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>
        }
        findFirst: {
          args: Prisma.CompetencyAssessmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompetencyAssessmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>
        }
        findMany: {
          args: Prisma.CompetencyAssessmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>[]
        }
        create: {
          args: Prisma.CompetencyAssessmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>
        }
        createMany: {
          args: Prisma.CompetencyAssessmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompetencyAssessmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>[]
        }
        delete: {
          args: Prisma.CompetencyAssessmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>
        }
        update: {
          args: Prisma.CompetencyAssessmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>
        }
        deleteMany: {
          args: Prisma.CompetencyAssessmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompetencyAssessmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompetencyAssessmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>[]
        }
        upsert: {
          args: Prisma.CompetencyAssessmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencyAssessmentPayload>
        }
        aggregate: {
          args: Prisma.CompetencyAssessmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompetencyAssessment>
        }
        groupBy: {
          args: Prisma.CompetencyAssessmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompetencyAssessmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompetencyAssessmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompetencyAssessmentCountAggregateOutputType> | number
        }
      }
    }
    CompetencySkillAssessment: {
      payload: Prisma.$CompetencySkillAssessmentPayload<ExtArgs>
      fields: Prisma.CompetencySkillAssessmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompetencySkillAssessmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompetencySkillAssessmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>
        }
        findFirst: {
          args: Prisma.CompetencySkillAssessmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompetencySkillAssessmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>
        }
        findMany: {
          args: Prisma.CompetencySkillAssessmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>[]
        }
        create: {
          args: Prisma.CompetencySkillAssessmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>
        }
        createMany: {
          args: Prisma.CompetencySkillAssessmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompetencySkillAssessmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>[]
        }
        delete: {
          args: Prisma.CompetencySkillAssessmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>
        }
        update: {
          args: Prisma.CompetencySkillAssessmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>
        }
        deleteMany: {
          args: Prisma.CompetencySkillAssessmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompetencySkillAssessmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompetencySkillAssessmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>[]
        }
        upsert: {
          args: Prisma.CompetencySkillAssessmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompetencySkillAssessmentPayload>
        }
        aggregate: {
          args: Prisma.CompetencySkillAssessmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompetencySkillAssessment>
        }
        groupBy: {
          args: Prisma.CompetencySkillAssessmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompetencySkillAssessmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompetencySkillAssessmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompetencySkillAssessmentCountAggregateOutputType> | number
        }
      }
    }
    SkillProgressEntry: {
      payload: Prisma.$SkillProgressEntryPayload<ExtArgs>
      fields: Prisma.SkillProgressEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SkillProgressEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SkillProgressEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>
        }
        findFirst: {
          args: Prisma.SkillProgressEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SkillProgressEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>
        }
        findMany: {
          args: Prisma.SkillProgressEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>[]
        }
        create: {
          args: Prisma.SkillProgressEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>
        }
        createMany: {
          args: Prisma.SkillProgressEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SkillProgressEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>[]
        }
        delete: {
          args: Prisma.SkillProgressEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>
        }
        update: {
          args: Prisma.SkillProgressEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>
        }
        deleteMany: {
          args: Prisma.SkillProgressEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SkillProgressEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SkillProgressEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>[]
        }
        upsert: {
          args: Prisma.SkillProgressEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SkillProgressEntryPayload>
        }
        aggregate: {
          args: Prisma.SkillProgressEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSkillProgressEntry>
        }
        groupBy: {
          args: Prisma.SkillProgressEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SkillProgressEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.SkillProgressEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SkillProgressEntryCountAggregateOutputType> | number
        }
      }
    }
    Admin: {
      payload: Prisma.$AdminPayload<ExtArgs>
      fields: Prisma.AdminFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AdminFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>
        }
        findFirst: {
          args: Prisma.AdminFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>
        }
        findMany: {
          args: Prisma.AdminFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>[]
        }
        create: {
          args: Prisma.AdminCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>
        }
        createMany: {
          args: Prisma.AdminCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>[]
        }
        delete: {
          args: Prisma.AdminDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>
        }
        update: {
          args: Prisma.AdminUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>
        }
        deleteMany: {
          args: Prisma.AdminDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AdminUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>[]
        }
        upsert: {
          args: Prisma.AdminUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminPayload>
        }
        aggregate: {
          args: Prisma.AdminAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAdmin>
        }
        groupBy: {
          args: Prisma.AdminGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdminGroupByOutputType>[]
        }
        count: {
          args: Prisma.AdminCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdminCountAggregateOutputType> | number
        }
      }
    }
    LeaveType: {
      payload: Prisma.$LeaveTypePayload<ExtArgs>
      fields: Prisma.LeaveTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>
        }
        findFirst: {
          args: Prisma.LeaveTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>
        }
        findMany: {
          args: Prisma.LeaveTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
        }
        create: {
          args: Prisma.LeaveTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>
        }
        createMany: {
          args: Prisma.LeaveTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
        }
        delete: {
          args: Prisma.LeaveTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>
        }
        update: {
          args: Prisma.LeaveTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>
        }
        deleteMany: {
          args: Prisma.LeaveTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
        }
        upsert: {
          args: Prisma.LeaveTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveTypePayload>
        }
        aggregate: {
          args: Prisma.LeaveTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaveType>
        }
        groupBy: {
          args: Prisma.LeaveTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveTypeCountAggregateOutputType> | number
        }
      }
    }
    LeavePolicy: {
      payload: Prisma.$LeavePolicyPayload<ExtArgs>
      fields: Prisma.LeavePolicyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeavePolicyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeavePolicyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
        }
        findFirst: {
          args: Prisma.LeavePolicyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeavePolicyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
        }
        findMany: {
          args: Prisma.LeavePolicyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>[]
        }
        create: {
          args: Prisma.LeavePolicyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
        }
        createMany: {
          args: Prisma.LeavePolicyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeavePolicyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>[]
        }
        delete: {
          args: Prisma.LeavePolicyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
        }
        update: {
          args: Prisma.LeavePolicyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
        }
        deleteMany: {
          args: Prisma.LeavePolicyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeavePolicyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeavePolicyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>[]
        }
        upsert: {
          args: Prisma.LeavePolicyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePolicyPayload>
        }
        aggregate: {
          args: Prisma.LeavePolicyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeavePolicy>
        }
        groupBy: {
          args: Prisma.LeavePolicyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeavePolicyGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeavePolicyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeavePolicyCountAggregateOutputType> | number
        }
      }
    }
    LeaveRequest: {
      payload: Prisma.$LeaveRequestPayload<ExtArgs>
      fields: Prisma.LeaveRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        findFirst: {
          args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        findMany: {
          args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        create: {
          args: Prisma.LeaveRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        createMany: {
          args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        delete: {
          args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        update: {
          args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        deleteMany: {
          args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        upsert: {
          args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        aggregate: {
          args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaveRequest>
        }
        groupBy: {
          args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveRequestCountAggregateOutputType> | number
        }
      }
    }
    LeaveBalance: {
      payload: Prisma.$LeaveBalancePayload<ExtArgs>
      fields: Prisma.LeaveBalanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveBalanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        findFirst: {
          args: Prisma.LeaveBalanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveBalanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        findMany: {
          args: Prisma.LeaveBalanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
        }
        create: {
          args: Prisma.LeaveBalanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        createMany: {
          args: Prisma.LeaveBalanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveBalanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
        }
        delete: {
          args: Prisma.LeaveBalanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        update: {
          args: Prisma.LeaveBalanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        deleteMany: {
          args: Prisma.LeaveBalanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveBalanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveBalanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
        }
        upsert: {
          args: Prisma.LeaveBalanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        aggregate: {
          args: Prisma.LeaveBalanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaveBalance>
        }
        groupBy: {
          args: Prisma.LeaveBalanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveBalanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveBalanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveBalanceCountAggregateOutputType> | number
        }
      }
    }
    Attendance: {
      payload: Prisma.$AttendancePayload<ExtArgs>
      fields: Prisma.AttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findFirst: {
          args: Prisma.AttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findMany: {
          args: Prisma.AttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        create: {
          args: Prisma.AttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        createMany: {
          args: Prisma.AttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        delete: {
          args: Prisma.AttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        update: {
          args: Prisma.AttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        deleteMany: {
          args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        upsert: {
          args: Prisma.AttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        aggregate: {
          args: Prisma.AttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendance>
        }
        groupBy: {
          args: Prisma.AttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCountAggregateOutputType> | number
        }
      }
    }
    WorkSchedule: {
      payload: Prisma.$WorkSchedulePayload<ExtArgs>
      fields: Prisma.WorkScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        findFirst: {
          args: Prisma.WorkScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        findMany: {
          args: Prisma.WorkScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
        }
        create: {
          args: Prisma.WorkScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        createMany: {
          args: Prisma.WorkScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
        }
        delete: {
          args: Prisma.WorkScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        update: {
          args: Prisma.WorkScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        deleteMany: {
          args: Prisma.WorkScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>[]
        }
        upsert: {
          args: Prisma.WorkScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkSchedulePayload>
        }
        aggregate: {
          args: Prisma.WorkScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkSchedule>
        }
        groupBy: {
          args: Prisma.WorkScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkScheduleCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const DepartmentScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


export const PositionScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  level: 'level',
  departmentId: 'departmentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


export const SkillScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  category: 'category',
  defaultLevel: 'defaultLevel',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


export const EmployeeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  hireDate: 'hireDate',
  departmentId: 'departmentId',
  positionId: 'positionId',
  managerId: 'managerId',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


export const EmployeeSkillScalarFieldEnum = {
  employeeId: 'employeeId',
  skillId: 'skillId',
  proficiency: 'proficiency',
  lastEvaluated: 'lastEvaluated'
} as const

export type EmployeeSkillScalarFieldEnum = (typeof EmployeeSkillScalarFieldEnum)[keyof typeof EmployeeSkillScalarFieldEnum]


export const ProjectScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  startDate: 'startDate',
  endDate: 'endDate',
  status: 'status',
  budget: 'budget',
  ownerId: 'ownerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


export const EmployeeProjectScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  projectId: 'projectId',
  role: 'role',
  startDate: 'startDate',
  endDate: 'endDate'
} as const

export type EmployeeProjectScalarFieldEnum = (typeof EmployeeProjectScalarFieldEnum)[keyof typeof EmployeeProjectScalarFieldEnum]


export const ProjectSkillScalarFieldEnum = {
  projectId: 'projectId',
  skillId: 'skillId'
} as const

export type ProjectSkillScalarFieldEnum = (typeof ProjectSkillScalarFieldEnum)[keyof typeof ProjectSkillScalarFieldEnum]


export const TrainingScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  provider: 'provider',
  type: 'type',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  difficulty: 'difficulty',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


export const TrainingSkillScalarFieldEnum = {
  trainingId: 'trainingId',
  skillId: 'skillId'
} as const

export type TrainingSkillScalarFieldEnum = (typeof TrainingSkillScalarFieldEnum)[keyof typeof TrainingSkillScalarFieldEnum]


export const EmployeeTrainingScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  trainingId: 'trainingId',
  status: 'status',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type EmployeeTrainingScalarFieldEnum = (typeof EmployeeTrainingScalarFieldEnum)[keyof typeof EmployeeTrainingScalarFieldEnum]


export const FeedbackScalarFieldEnum = {
  id: 'id',
  authorId: 'authorId',
  recipientId: 'recipientId',
  type: 'type',
  sentiment: 'sentiment',
  title: 'title',
  content: 'content',
  rating: 'rating',
  tags: 'tags',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


export const RecommendationScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  title: 'title',
  description: 'description',
  source: 'source',
  priority: 'priority',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RecommendationScalarFieldEnum = (typeof RecommendationScalarFieldEnum)[keyof typeof RecommendationScalarFieldEnum]


export const RecommendationSkillScalarFieldEnum = {
  recommendationId: 'recommendationId',
  skillId: 'skillId'
} as const

export type RecommendationSkillScalarFieldEnum = (typeof RecommendationSkillScalarFieldEnum)[keyof typeof RecommendationSkillScalarFieldEnum]


export const PerformanceReviewScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  reviewerId: 'reviewerId',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  status: 'status',
  overallRating: 'overallRating',
  strengths: 'strengths',
  improvements: 'improvements',
  comments: 'comments',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PerformanceReviewScalarFieldEnum = (typeof PerformanceReviewScalarFieldEnum)[keyof typeof PerformanceReviewScalarFieldEnum]


export const GoalScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  title: 'title',
  description: 'description',
  type: 'type',
  priority: 'priority',
  status: 'status',
  startDate: 'startDate',
  targetDate: 'targetDate',
  progress: 'progress',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


export const DevelopmentPlanScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  title: 'title',
  description: 'description',
  status: 'status',
  startDate: 'startDate',
  targetDate: 'targetDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DevelopmentPlanScalarFieldEnum = (typeof DevelopmentPlanScalarFieldEnum)[keyof typeof DevelopmentPlanScalarFieldEnum]


export const DevelopmentPlanItemScalarFieldEnum = {
  id: 'id',
  developmentPlanId: 'developmentPlanId',
  title: 'title',
  description: 'description',
  status: 'status',
  skillId: 'skillId',
  dueDate: 'dueDate',
  completedAt: 'completedAt'
} as const

export type DevelopmentPlanItemScalarFieldEnum = (typeof DevelopmentPlanItemScalarFieldEnum)[keyof typeof DevelopmentPlanItemScalarFieldEnum]


export const MentoringRelationshipScalarFieldEnum = {
  id: 'id',
  mentorId: 'mentorId',
  menteeId: 'menteeId',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  goals: 'goals',
  notes: 'notes'
} as const

export type MentoringRelationshipScalarFieldEnum = (typeof MentoringRelationshipScalarFieldEnum)[keyof typeof MentoringRelationshipScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  channel: 'channel',
  status: 'status',
  title: 'title',
  message: 'message',
  metadata: 'metadata',
  sentAt: 'sentAt',
  readAt: 'readAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const NotificationPreferenceScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  channel: 'channel',
  enabled: 'enabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


export const OnboardingScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  status: 'status',
  startDate: 'startDate',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingScalarFieldEnum = (typeof OnboardingScalarFieldEnum)[keyof typeof OnboardingScalarFieldEnum]


export const OnboardingTaskScalarFieldEnum = {
  id: 'id',
  onboardingId: 'onboardingId',
  title: 'title',
  description: 'description',
  dueDate: 'dueDate',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingTaskScalarFieldEnum = (typeof OnboardingTaskScalarFieldEnum)[keyof typeof OnboardingTaskScalarFieldEnum]


export const OffboardingScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  status: 'status',
  exitDate: 'exitDate',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OffboardingScalarFieldEnum = (typeof OffboardingScalarFieldEnum)[keyof typeof OffboardingScalarFieldEnum]


export const OffboardingTaskScalarFieldEnum = {
  id: 'id',
  offboardingId: 'offboardingId',
  title: 'title',
  description: 'description',
  dueDate: 'dueDate',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OffboardingTaskScalarFieldEnum = (typeof OffboardingTaskScalarFieldEnum)[keyof typeof OffboardingTaskScalarFieldEnum]


export const EmployeeJourneyScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  departmentId: 'departmentId',
  positionId: 'positionId',
  type: 'type',
  description: 'description',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EmployeeJourneyScalarFieldEnum = (typeof EmployeeJourneyScalarFieldEnum)[keyof typeof EmployeeJourneyScalarFieldEnum]


export const EmployeeJourneyTouchpointScalarFieldEnum = {
  id: 'id',
  journeyId: 'journeyId',
  title: 'title',
  description: 'description',
  occurredAt: 'occurredAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EmployeeJourneyTouchpointScalarFieldEnum = (typeof EmployeeJourneyTouchpointScalarFieldEnum)[keyof typeof EmployeeJourneyTouchpointScalarFieldEnum]


export const CareerPathScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CareerPathScalarFieldEnum = (typeof CareerPathScalarFieldEnum)[keyof typeof CareerPathScalarFieldEnum]


export const CareerPathStageScalarFieldEnum = {
  id: 'id',
  careerPathId: 'careerPathId',
  title: 'title',
  description: 'description',
  order: 'order'
} as const

export type CareerPathStageScalarFieldEnum = (typeof CareerPathStageScalarFieldEnum)[keyof typeof CareerPathStageScalarFieldEnum]


export const CareerPathPositionScalarFieldEnum = {
  careerPathId: 'careerPathId',
  positionId: 'positionId'
} as const

export type CareerPathPositionScalarFieldEnum = (typeof CareerPathPositionScalarFieldEnum)[keyof typeof CareerPathPositionScalarFieldEnum]


export const CareerPathSkillScalarFieldEnum = {
  careerPathId: 'careerPathId',
  skillId: 'skillId'
} as const

export type CareerPathSkillScalarFieldEnum = (typeof CareerPathSkillScalarFieldEnum)[keyof typeof CareerPathSkillScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  action: 'action',
  entity: 'entity',
  entityId: 'entityId',
  oldValue: 'oldValue',
  newValue: 'newValue',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const KnowledgeArticleScalarFieldEnum = {
  id: 'id',
  authorId: 'authorId',
  departmentId: 'departmentId',
  title: 'title',
  content: 'content',
  category: 'category',
  tags: 'tags',
  publishedAt: 'publishedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type KnowledgeArticleScalarFieldEnum = (typeof KnowledgeArticleScalarFieldEnum)[keyof typeof KnowledgeArticleScalarFieldEnum]


export const KnowledgeArticleSkillScalarFieldEnum = {
  articleId: 'articleId',
  skillId: 'skillId'
} as const

export type KnowledgeArticleSkillScalarFieldEnum = (typeof KnowledgeArticleSkillScalarFieldEnum)[keyof typeof KnowledgeArticleSkillScalarFieldEnum]


export const AssessmentPeriodScalarFieldEnum = {
  id: 'id',
  name: 'name',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssessmentPeriodScalarFieldEnum = (typeof AssessmentPeriodScalarFieldEnum)[keyof typeof AssessmentPeriodScalarFieldEnum]


export const CompetencyAssessmentScalarFieldEnum = {
  id: 'id',
  periodId: 'periodId',
  employeeId: 'employeeId',
  reviewerId: 'reviewerId',
  status: 'status',
  overallScore: 'overallScore',
  comments: 'comments',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompetencyAssessmentScalarFieldEnum = (typeof CompetencyAssessmentScalarFieldEnum)[keyof typeof CompetencyAssessmentScalarFieldEnum]


export const CompetencySkillAssessmentScalarFieldEnum = {
  id: 'id',
  assessmentId: 'assessmentId',
  skillId: 'skillId',
  rating: 'rating',
  comments: 'comments',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompetencySkillAssessmentScalarFieldEnum = (typeof CompetencySkillAssessmentScalarFieldEnum)[keyof typeof CompetencySkillAssessmentScalarFieldEnum]


export const SkillProgressEntryScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  skillId: 'skillId',
  proficiency: 'proficiency',
  evidence: 'evidence',
  createdAt: 'createdAt'
} as const

export type SkillProgressEntryScalarFieldEnum = (typeof SkillProgressEntryScalarFieldEnum)[keyof typeof SkillProgressEntryScalarFieldEnum]


export const AdminScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  role: 'role',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


export const LeaveTypeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  code: 'code',
  maxDays: 'maxDays',
  carryForward: 'carryForward',
  requiresApproval: 'requiresApproval',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaveTypeScalarFieldEnum = (typeof LeaveTypeScalarFieldEnum)[keyof typeof LeaveTypeScalarFieldEnum]


export const LeavePolicyScalarFieldEnum = {
  id: 'id',
  leaveTypeId: 'leaveTypeId',
  departmentId: 'departmentId',
  positionId: 'positionId',
  maxDays: 'maxDays',
  minDays: 'minDays',
  accrualRate: 'accrualRate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeavePolicyScalarFieldEnum = (typeof LeavePolicyScalarFieldEnum)[keyof typeof LeavePolicyScalarFieldEnum]


export const LeaveRequestScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  leaveTypeId: 'leaveTypeId',
  startDate: 'startDate',
  endDate: 'endDate',
  days: 'days',
  reason: 'reason',
  status: 'status',
  approverId: 'approverId',
  approvedAt: 'approvedAt',
  rejectedReason: 'rejectedReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


export const LeaveBalanceScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  leaveTypeId: 'leaveTypeId',
  balance: 'balance',
  accrued: 'accrued',
  used: 'used',
  year: 'year',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaveBalanceScalarFieldEnum = (typeof LeaveBalanceScalarFieldEnum)[keyof typeof LeaveBalanceScalarFieldEnum]


export const AttendanceScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  date: 'date',
  checkIn: 'checkIn',
  checkOut: 'checkOut',
  workHours: 'workHours',
  status: 'status',
  location: 'location',
  notes: 'notes',
  lateMinutes: 'lateMinutes',
  overtimeHours: 'overtimeHours',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


export const WorkScheduleScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  departmentId: 'departmentId',
  positionId: 'positionId',
  name: 'name',
  startTime: 'startTime',
  endTime: 'endTime',
  breakDuration: 'breakDuration',
  workDays: 'workDays',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkScheduleScalarFieldEnum = (typeof WorkScheduleScalarFieldEnum)[keyof typeof WorkScheduleScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'SkillType'
 */
export type EnumSkillTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillType'>
    


/**
 * Reference to a field of type 'SkillType[]'
 */
export type ListEnumSkillTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillType[]'>
    


/**
 * Reference to a field of type 'SkillCategory'
 */
export type EnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory'>
    


/**
 * Reference to a field of type 'SkillCategory[]'
 */
export type ListEnumSkillCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillCategory[]'>
    


/**
 * Reference to a field of type 'SkillLevel'
 */
export type EnumSkillLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillLevel'>
    


/**
 * Reference to a field of type 'SkillLevel[]'
 */
export type ListEnumSkillLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SkillLevel[]'>
    


/**
 * Reference to a field of type 'ProjectStatus'
 */
export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


/**
 * Reference to a field of type 'ProjectStatus[]'
 */
export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'TrainingType'
 */
export type EnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType'>
    


/**
 * Reference to a field of type 'TrainingType[]'
 */
export type ListEnumTrainingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingType[]'>
    


/**
 * Reference to a field of type 'TrainingStatus'
 */
export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


/**
 * Reference to a field of type 'TrainingStatus[]'
 */
export type ListEnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus[]'>
    


/**
 * Reference to a field of type 'FeedbackType'
 */
export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


/**
 * Reference to a field of type 'FeedbackType[]'
 */
export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


/**
 * Reference to a field of type 'SentimentType'
 */
export type EnumSentimentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SentimentType'>
    


/**
 * Reference to a field of type 'SentimentType[]'
 */
export type ListEnumSentimentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SentimentType[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'RecommendationSource'
 */
export type EnumRecommendationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationSource'>
    


/**
 * Reference to a field of type 'RecommendationSource[]'
 */
export type ListEnumRecommendationSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationSource[]'>
    


/**
 * Reference to a field of type 'RecommendationPriority'
 */
export type EnumRecommendationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationPriority'>
    


/**
 * Reference to a field of type 'RecommendationPriority[]'
 */
export type ListEnumRecommendationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationPriority[]'>
    


/**
 * Reference to a field of type 'RecommendationStatus'
 */
export type EnumRecommendationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationStatus'>
    


/**
 * Reference to a field of type 'RecommendationStatus[]'
 */
export type ListEnumRecommendationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecommendationStatus[]'>
    


/**
 * Reference to a field of type 'PerformanceReviewStatus'
 */
export type EnumPerformanceReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerformanceReviewStatus'>
    


/**
 * Reference to a field of type 'PerformanceReviewStatus[]'
 */
export type ListEnumPerformanceReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PerformanceReviewStatus[]'>
    


/**
 * Reference to a field of type 'GoalType'
 */
export type EnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType'>
    


/**
 * Reference to a field of type 'GoalType[]'
 */
export type ListEnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType[]'>
    


/**
 * Reference to a field of type 'GoalPriority'
 */
export type EnumGoalPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalPriority'>
    


/**
 * Reference to a field of type 'GoalPriority[]'
 */
export type ListEnumGoalPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalPriority[]'>
    


/**
 * Reference to a field of type 'GoalStatus'
 */
export type EnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus'>
    


/**
 * Reference to a field of type 'GoalStatus[]'
 */
export type ListEnumGoalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalStatus[]'>
    


/**
 * Reference to a field of type 'DevelopmentPlanStatus'
 */
export type EnumDevelopmentPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevelopmentPlanStatus'>
    


/**
 * Reference to a field of type 'DevelopmentPlanStatus[]'
 */
export type ListEnumDevelopmentPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevelopmentPlanStatus[]'>
    


/**
 * Reference to a field of type 'DevelopmentItemStatus'
 */
export type EnumDevelopmentItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevelopmentItemStatus'>
    


/**
 * Reference to a field of type 'DevelopmentItemStatus[]'
 */
export type ListEnumDevelopmentItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DevelopmentItemStatus[]'>
    


/**
 * Reference to a field of type 'MentoringStatus'
 */
export type EnumMentoringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentoringStatus'>
    


/**
 * Reference to a field of type 'MentoringStatus[]'
 */
export type ListEnumMentoringStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentoringStatus[]'>
    


/**
 * Reference to a field of type 'NotificationChannel'
 */
export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


/**
 * Reference to a field of type 'NotificationChannel[]'
 */
export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


/**
 * Reference to a field of type 'NotificationStatus'
 */
export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


/**
 * Reference to a field of type 'NotificationStatus[]'
 */
export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'OnboardingStatus'
 */
export type EnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus'>
    


/**
 * Reference to a field of type 'OnboardingStatus[]'
 */
export type ListEnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus[]'>
    


/**
 * Reference to a field of type 'OffboardingStatus'
 */
export type EnumOffboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OffboardingStatus'>
    


/**
 * Reference to a field of type 'OffboardingStatus[]'
 */
export type ListEnumOffboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OffboardingStatus[]'>
    


/**
 * Reference to a field of type 'EmployeeJourneyStatus'
 */
export type EnumEmployeeJourneyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeJourneyStatus'>
    


/**
 * Reference to a field of type 'EmployeeJourneyStatus[]'
 */
export type ListEnumEmployeeJourneyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeJourneyStatus[]'>
    


/**
 * Reference to a field of type 'AuditAction'
 */
export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


/**
 * Reference to a field of type 'AuditAction[]'
 */
export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


/**
 * Reference to a field of type 'KnowledgeCategory'
 */
export type EnumKnowledgeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeCategory'>
    


/**
 * Reference to a field of type 'KnowledgeCategory[]'
 */
export type ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeCategory[]'>
    


/**
 * Reference to a field of type 'AssessmentPeriodStatus'
 */
export type EnumAssessmentPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentPeriodStatus'>
    


/**
 * Reference to a field of type 'AssessmentPeriodStatus[]'
 */
export type ListEnumAssessmentPeriodStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssessmentPeriodStatus[]'>
    


/**
 * Reference to a field of type 'CompetencyAssessmentStatus'
 */
export type EnumCompetencyAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompetencyAssessmentStatus'>
    


/**
 * Reference to a field of type 'CompetencyAssessmentStatus[]'
 */
export type ListEnumCompetencyAssessmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompetencyAssessmentStatus[]'>
    


/**
 * Reference to a field of type 'AdminRole'
 */
export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


/**
 * Reference to a field of type 'AdminRole[]'
 */
export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


/**
 * Reference to a field of type 'LeaveStatus'
 */
export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


/**
 * Reference to a field of type 'LeaveStatus[]'
 */
export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


/**
 * Reference to a field of type 'AttendanceStatus'
 */
export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


/**
 * Reference to a field of type 'AttendanceStatus[]'
 */
export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  department?: Prisma.DepartmentOmit
  position?: Prisma.PositionOmit
  skill?: Prisma.SkillOmit
  employee?: Prisma.EmployeeOmit
  employeeSkill?: Prisma.EmployeeSkillOmit
  project?: Prisma.ProjectOmit
  employeeProject?: Prisma.EmployeeProjectOmit
  projectSkill?: Prisma.ProjectSkillOmit
  training?: Prisma.TrainingOmit
  trainingSkill?: Prisma.TrainingSkillOmit
  employeeTraining?: Prisma.EmployeeTrainingOmit
  feedback?: Prisma.FeedbackOmit
  recommendation?: Prisma.RecommendationOmit
  recommendationSkill?: Prisma.RecommendationSkillOmit
  performanceReview?: Prisma.PerformanceReviewOmit
  goal?: Prisma.GoalOmit
  developmentPlan?: Prisma.DevelopmentPlanOmit
  developmentPlanItem?: Prisma.DevelopmentPlanItemOmit
  mentoringRelationship?: Prisma.MentoringRelationshipOmit
  notification?: Prisma.NotificationOmit
  notificationPreference?: Prisma.NotificationPreferenceOmit
  onboarding?: Prisma.OnboardingOmit
  onboardingTask?: Prisma.OnboardingTaskOmit
  offboarding?: Prisma.OffboardingOmit
  offboardingTask?: Prisma.OffboardingTaskOmit
  employeeJourney?: Prisma.EmployeeJourneyOmit
  employeeJourneyTouchpoint?: Prisma.EmployeeJourneyTouchpointOmit
  careerPath?: Prisma.CareerPathOmit
  careerPathStage?: Prisma.CareerPathStageOmit
  careerPathPosition?: Prisma.CareerPathPositionOmit
  careerPathSkill?: Prisma.CareerPathSkillOmit
  auditLog?: Prisma.AuditLogOmit
  knowledgeArticle?: Prisma.KnowledgeArticleOmit
  knowledgeArticleSkill?: Prisma.KnowledgeArticleSkillOmit
  assessmentPeriod?: Prisma.AssessmentPeriodOmit
  competencyAssessment?: Prisma.CompetencyAssessmentOmit
  competencySkillAssessment?: Prisma.CompetencySkillAssessmentOmit
  skillProgressEntry?: Prisma.SkillProgressEntryOmit
  admin?: Prisma.AdminOmit
  leaveType?: Prisma.LeaveTypeOmit
  leavePolicy?: Prisma.LeavePolicyOmit
  leaveRequest?: Prisma.LeaveRequestOmit
  leaveBalance?: Prisma.LeaveBalanceOmit
  attendance?: Prisma.AttendanceOmit
  workSchedule?: Prisma.WorkScheduleOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

